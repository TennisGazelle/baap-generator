from flask import request, send_file
import yamale
import json
import shutil
import os
import sys
import requests
import zipfile
from pathlib import Path
import logging
import time


logging.basicConfig(level=os.environ.get("LOGLEVEL", "DEBUG"))
log = logging.getLogger(__doc__)


VERSION = "0.1.1"
SCHEMA_FILE='config_schema.yaml'
schema = yamale.make_schema(SCHEMA_FILE)
tempdir = 'tempdir/'

class Validator:
    def __init__(self):
        self.default_name = 'baap-template'
        self.release_zip = tempdir + self.default_name + ".zip"
        self.release_dir = tempdir + self.default_name + "/"
        self.release_makefile = tempdir + self.default_name + "/Makefile"
        self.release_config = tempdir + self.default_name + "/config.yaml"

    def get_dir(self, hash):
        return tempdir + "{}/".format(hash) 
        

    def generate_makefile(self, filename):
        makefile_contents = [
            "#",
            "#",
            "# Makefile Generated by validator.py (tennisgazelle)",
            "#",
            "#",
            ""
        ]

        render_contents = []
        get_paths_contents = set()
        set_paths_contents = set()
        all_recipe_names = []

        for stage in self.stages:
            if stage[0] == '_':
                continue
            recipe_name = stage + '_render'
            blend_file = self.stages[stage]['blend_file']

            all_recipe_names.append(recipe_name)
            render_contents.append(f'{recipe_name}: blender/{self.stages[stage]["blend_file"]}')
            render_contents.append(f'\tpython3 scripts/render.py --stage {stage}')
            render_contents.append('')
            get_paths_contents.add(f'\tdocker run --rm -v ${{PWD}}/blender/:/blender/ -v ${{PWD}}/scripts:/scripts -v ${{PWD}}/config.yaml:/config.yaml tennisgazelle/blender-pipeline:latest blender/{blend_file} --python scripts/get_path.py')
            set_paths_contents.add(f'\tdocker run --rm -v ${{PWD}}/blender/:/blender/ -v ${{PWD}}/scripts:/scripts -v ${{PWD}}/config.yaml:/config.yaml tennisgazelle/blender-pipeline:latest blender/{blend_file} --python scripts/set_path.py')

        for model in self.models:
            if model[0] == '_':
                continue
            recipe_name = model + '_model_render'

            all_recipe_names.append(recipe_name)
            render_contents.append(f'{recipe_name}: {self.models[model]["obj_file"]}')
            render_contents.append(f'\tdocker run --rm -v ${{PWD}}/dump:/tmp -v ${{PWD}}/blender/:/blender/ -v ${{PWD}}/scripts:/scripts -v ${{PWD}}/config.yaml:/config.yaml -v ${{PWD}}/imgs/:/imgs tennisgazelle/blender-pipeline:latest --python scripts/obj-render.py -- --output_folder {self.models[model]["render_output"]} {self.models[model]["obj_file"]}')
            render_contents.append('')


        makefile_contents = makefile_contents + \
                ["all: " + " ".join(all_recipe_names)] + [""] + \
                render_contents + \
                ["get_paths:"] + list(get_paths_contents) + [""] + \
                ["set_paths:"] + list(set_paths_contents) + [""] + [
                    "clean:",
                    "\trm -rf out/",
                    "",
                    "clean_buffers:",
                    "\trm -rf buffer/"
                ]

        with open(filename, 'w+') as mfhandle:
            mfhandle.writelines("%s\n" % line for line in makefile_contents)

    def save_file_and_validate(self, uploaded_file, destination_file):
        uploaded_file.save(destination_file)
        uploaded_yamale = yamale.make_data(destination_file)
        return uploaded_yamale[0][0]

    def generate_project(self):
        self.get_latest_release()

        if request.files:
            log.info(f'processing new request with files')
            uploaded_config_file = request.files.getlist('payload')[0]
            instance_hash = str(hash(uploaded_config_file))[:6]
            instance_config = self.get_dir(instance_hash) + 'config.yaml'
            instance_zip = self.get_dir(instance_hash) + '{}-baap.zip'.format(instance_hash)
            instance_makefile = self.get_dir(instance_hash) + 'Makefile'

            try:
                log.info(f'{instance_hash} being processed')
                os.mkdir(self.get_dir(instance_hash))
                self.uploaded_yamale = self.save_file_and_validate(uploaded_config_file, instance_config)
                self.stages = self.uploaded_yamale['stages']
                self.models = self.uploaded_yamale['models']
                self.docker = self.uploaded_yamale['docker']
            except Exception as err:
                log.warn(f'{instance_hash} failed, bad yaml')
                return {
                    "error": "Bad yaml",
                    "msg": str(err)
                }

            # generate new zip file
            self.copy_from_main(instance_hash)
            uploaded_config_file.save(instance_config)
            log.info(f'generating makefile {instance_hash}...')
            self.generate_makefile(instance_makefile)
            log.info(f'zipping {instance_hash}...')
            self.zip_project(instance_zip, instance_hash)

            log.info(f'returning {instance_hash}...')
            return send_file('../' + instance_zip)
        else:
            return send_file('../' + self.release_zip)
    
    def copy_from_main(self, hash):
        destination = self.get_dir(hash)
        if os.path.exists(destination):
            shutil.rmtree(destination)
        shutil.copytree(self.release_dir, destination)

    def zip_project(self, zip_filename, hash):
        with zipfile.ZipFile(zip_filename, 'w') as zip_file:
            zip_file.write(self.get_dir(hash))
            for dirname, _, files in os.walk(self.get_dir(hash)):
                # zip_file.write(dirname)
                for filename in files:
                    zip_file.write(os.path.join(dirname, filename))
                    print(f'writing {os.path.join(dirname, filename)}')
            zip_file.close()

    # should probably be static but would need a lot of params
    def get_latest_release(self):
        # ensuring tempdir exists
        if not os.path.exists(tempdir) or not os.path.isdir(tempdir):
            log.info(f'creating {tempdir}...')
            os.mkdir(tempdir)

        # ensuring tempdir/self.release_zip exists
        if not os.path.exists(self.release_zip) or not os.path.isfile(self.release_zip):
            url = f"https://api.github.com/repos/TennisGazelle/blender-pipeline/zipball/v{VERSION}"
            log.info(f'fetching latest {self.release_zip} from {url}...')
            r = requests.get(url)
            open(self.release_zip, 'wb+').write(r.content)

        # ensuring tempdir/self.release_dir (made from the self.release_zip) is made
        if not os.path.exists(self.release_dir) or not os.path.isdir(self.release_dir):
            log.info(f'extracting zip...')
            with zipfile.ZipFile(self.release_zip, 'r') as zip_file:
                top_level_dir = zip_file.infolist()[0].filename
                zip_file.extractall(tempdir)
                os.rename(tempdir + top_level_dir, self.release_dir)

                # blender_pipeline_dir = "blender-pipeline-" + VERSION + "/"



def save_file_and_validate(uploaded_file, path):
    filename = path + "/" + uploaded_file.filename
    uploaded_file.save(filename)

    uploaded_yamale = yamale.make_data(filename)

    return uploaded_yamale


def generate_makefile(stages, models, makefileName):
    makefile_contents = [
        "#",
        "#",
        "# Makefile Generated by validator.py (tennisgazelle)",
        "#",
        "#",
        ""
    ]

    render_contents = []
    get_paths_contents = set()
    set_paths_contents = set()
    all_recipe_names = []

    for stage in stages:
        recipe_name = stage + '_render'
        blend_file = stages[stage]['blend_file']

        all_recipe_names.append(recipe_name)
        render_contents.append(f'{recipe_name}: blender/{blend_file}')
        render_contents.append(f'\tpython3 scripts/render.py --stage {stage}')
        render_contents.append('')
        get_paths_contents.add(f'\tdocker run --rm -v ${{PWD}}/blender/:/blender/ -v ${{PWD}}/scripts:/scripts -v ${{PWD}}/config.yaml:/config.yaml tennisgazelle/blender-pipeline:latest blender/{blend_file} --python scripts/get_path.py')
        set_paths_contents.add(f'\tdocker run --rm -v ${{PWD}}/blender/:/blender/ -v ${{PWD}}/scripts:/scripts -v ${{PWD}}/config.yaml:/config.yaml tennisgazelle/blender-pipeline:latest blender/{blend_file} --python scripts/set_path.py')

    makefile_contents = makefile_contents + \
            ["all: " + " ".join(all_recipe_names)] + [""] + \
            render_contents + \
            ["get_paths:"] + list(get_paths_contents) + [""] + \
            ["set_paths:"] + list(set_paths_contents) + [""] + [
                "clean:",
                "\trm -rf out/",
                "",
                "clean_buffers:",
                "\trm -rf buffer/"
            ]

    with open(makefileName, 'w+') as mfhandle:
        mfhandle.writelines("%s\n" % line for line in makefile_contents)



def hello_world(request):
    request_json = request.get_json()
    if request_json and 'name' in request_json:
        name = request_json['name']
    else:
        name = 'World'
    return 'Hello, {}!\n'.format(name)



def generateRelease():
    r = requests.get("https://github.com/TennisGazelle/blender-pipeline/archive/refs/tags/v0.0.1.zip")
    open('baap-template.zip', 'wb').write(r.content)
    

    with zipfile.ZipFile('baap-template.zip', 'r') as zip_file:
        zip_file.extractall(tempdir)
        blender_pipeline_dir = "blender-pipeline-" + VERSION + "/"

    if request.files:
        uploaded_config_file = request.files.getlist('payload')[0]
        configFile = uploaded_config_file.filename
        
        try:
            uploaded_yamale = save_file_and_validate(uploaded_config_file, tempdir)[0][0]
        except Exception as err:
            return {
                "error": "Bad yaml",
                "msg": str(err)
            }

        print('===> generating for config...', uploaded_yamale)
        generate_makefile(uploaded_yamale['stages'], uploaded_yamale['models'], tempdir + blender_pipeline_dir + 'Makefile')

        print('====> copying config...')
        os.rename(tempdir + configFile, tempdir + blender_pipeline_dir + "config.yaml")


        print('zipping....')
        with zipfile.ZipFile('baap-template.zip', 'w') as myzip:
            myzip.write(tempdir + blender_pipeline_dir)
            for dirname, _, files in os.walk(tempdir + blender_pipeline_dir):
                myzip.write(dirname)

                for filename in files:
                    myzip.write(os.path.join(dirname, filename))

            myzip.close()


        return send_file('baap-template.zip')

# @app.route("/validate", methods=["POST"])
def validateAgainstSchema():
    data = {}

    if request.files:
        for uploaded_file in request.files.getlist('payload'):
            if uploaded_file.filename != '':
                data[uploaded_file.filename] = {}
                try:
                    uploaded_yamale = save_file_and_validate(uploaded_file, ".")
                    data[uploaded_file.filename] = {
                        "error": None
                    }
                except Exception as err:
                    data[uploaded_file.filename] = {
                        "error": "Malformed yaml",
                        "msg": str(err)
                    }

    else:
        data = request.get_json(force=True)


    return {
        "request": data
    }


if __name__ == "__main__":
    v = Validator()
    v.generate_project()



# CONFIG_FILE='./config.yaml'


# def init_config():
#     # validate the yaml first
#     import yamale
#     schema = yamale.make_schema(SCHEMA_FILE)
#     # Create a Data object
#     data = yamale.make_data(CONFIG_FILE)
#     # Validate data against the schema. Throws a ValueError if data is invalid.
#     yamale.validate(schema, data)

#     # return it if it works
#     with open('config.yaml', 'r') as config_file:
#         config = yaml.load(config_file)#, Loader=yaml.FullLoader) # fix this