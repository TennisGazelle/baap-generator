from flask import request, send_file
import yamale
import json
import shutil
import os
import sys
import requests
import zipfile
from pathlib import Path
import logging
import time


logging.basicConfig(level=os.environ.get("LOGLEVEL", "DEBUG"))
log = logging.getLogger(__doc__)


VERSION = "0.1.1"
SCHEMA_FILE='config_schema.yaml'
schema = yamale.make_schema(SCHEMA_FILE)
tempdir = 'tempdir/'

class Validator:
    def __init__(self):
        self.default_name = 'baap-template'
        self.release_zip = tempdir + self.default_name + ".zip"
        self.release_dir = tempdir + self.default_name + "/"
        self.release_makefile = tempdir + self.default_name + "/Makefile"
        self.release_config = tempdir + self.default_name + "/config.yaml"

    def get_dir(self, hash):
        return tempdir + "{}-baap/".format(hash)
        

    def generate_makefile(self, filename):
        makefile_contents = [
            "#",
            "#",
            "# Makefile Generated by validator.py (tennisgazelle)",
            "#",
            "#",
            ""
        ]

        render_contents = []
        get_paths_contents = set()
        set_paths_contents = set()
        all_recipe_names = []

        for stage in self.stages:
            if stage[0] == '_':
                continue
            recipe_name = stage + '_render'
            blend_file = self.stages[stage]['blend_file']

            all_recipe_names.append(recipe_name)
            render_contents.append(f'{recipe_name}: blender/{self.stages[stage]["blend_file"]}')
            render_contents.append(f'\tpython3 scripts/render.py --stage {stage}')
            render_contents.append('')
            get_paths_contents.add(f'\tdocker run --rm -v ${{PWD}}/blender/:/blender/ -v ${{PWD}}/scripts:/scripts -v ${{PWD}}/config.yaml:/config.yaml tennisgazelle/blender-pipeline:latest blender/{blend_file} --python scripts/get_path.py')
            set_paths_contents.add(f'\tdocker run --rm -v ${{PWD}}/blender/:/blender/ -v ${{PWD}}/scripts:/scripts -v ${{PWD}}/config.yaml:/config.yaml tennisgazelle/blender-pipeline:latest blender/{blend_file} --python scripts/set_path.py')

        for model in self.models:
            if model[0] == '_':
                continue
            recipe_name = model + '_model_render'

            all_recipe_names.append(recipe_name)
            render_contents.append(f'{recipe_name}: {self.models[model]["obj_file"]}')
            render_contents.append(f'\tdocker run --rm -v ${{PWD}}/dump:/tmp -v ${{PWD}}/blender/:/blender/ -v ${{PWD}}/scripts:/scripts -v ${{PWD}}/config.yaml:/config.yaml -v ${{PWD}}/imgs/:/imgs tennisgazelle/blender-pipeline:latest --python scripts/obj-render.py -- --output_folder {self.models[model]["render_output"]} {self.models[model]["obj_file"]}')
            render_contents.append('')


        makefile_contents = makefile_contents + \
                ["all: " + " ".join(all_recipe_names)] + [""] + \
                render_contents + \
                ["get_paths:"] + list(get_paths_contents) + [""] + \
                ["set_paths:"] + list(set_paths_contents) + [""] + [
                    "clean:",
                    "\trm -rf out/",
                    "",
                    "clean_buffers:",
                    "\trm -rf buffer/"
                ]

        with open(filename, 'w+') as mfhandle:
            mfhandle.writelines("%s\n" % line for line in makefile_contents)

    def save_file_and_validate(self, uploaded_file, destination_file):
        uploaded_file.save(destination_file)
        uploaded_yamale = yamale.make_data(destination_file)
        return uploaded_yamale[0][0]

    def generate_project(self):
        self.get_latest_release()

        if request.files:
            uploaded_config_file = request.files.getlist('payload')[0]
            instance_hash = str(hash(uploaded_config_file))[1:7] # first 6 digits, ignore potential minus
            instance_config = self.get_dir(instance_hash) + 'config.yaml'
            instance_zip = self.get_dir(instance_hash) + '{}.zip'.format(instance_hash)
            instance_makefile = self.get_dir(instance_hash) + 'Makefile'

            try:
                log.info(f'{instance_hash} processing')
                # if os.path.exists(self.get_dir(instance_hash)):
                #     os.clean(self.get_dir(instance_hash))
                if os.path.exists(self.get_dir(instance_hash)):
                    shutil.rmtree(self.get_dir(instance_hash))
                os.mkdir(self.get_dir(instance_hash))

                self.uploaded_yamale = self.save_file_and_validate(uploaded_config_file, instance_config)
                self.stages = self.uploaded_yamale['stages']
                self.models = self.uploaded_yamale['models']
                self.docker = self.uploaded_yamale['docker']
            except Exception as err:
                log.warn(f'{instance_hash} failed, bad yaml')
                log.warn(err)
                return {
                    "error": "Bad yaml",
                    "msg": str(err)
                }

            # generate new zip file
            self.copy_from_main(instance_hash)
            uploaded_config_file.save(instance_config)
            log.info(f'{instance_hash} generating makefile...')
            self.generate_makefile(instance_makefile)
            log.info(f'{instance_hash} zipping...')
            self.zip_project(instance_zip, instance_hash)

            log.info(f'{instance_hash} returning...')
            return send_file('../' + instance_zip)
        else:
            return send_file('../' + self.release_zip)
    
    def copy_from_main(self, hash):
        destination = self.get_dir(hash)
        if os.path.exists(destination):
            shutil.rmtree(destination)
        shutil.copytree(self.release_dir, destination)

    def zip_project(self, zip_filename, hash):
        with zipfile.ZipFile(zip_filename, 'w') as zip_file:
            zip_file.write(self.get_dir(hash))
            for dirname, _, files in os.walk(self.get_dir(hash)):
                # zip_file.write(dirname)
                for filename in files:
                    if filename in zip_filename:
                        continue
                    log.info(f'{hash} zipping {os.path.join(dirname, filename).replace("tempdir/", "")}')
                    zip_file.write(os.path.join(dirname, filename))

            zip_file.close()

    # should probably be static but would need a lot of params
    def get_latest_release(self):
        # ensuring tempdir exists
        if not os.path.exists(tempdir) or not os.path.isdir(tempdir):
            log.info(f'creating {tempdir}...')
            os.mkdir(tempdir)

        # ensuring tempdir/self.release_zip exists
        if not os.path.exists(self.release_zip) or not os.path.isfile(self.release_zip):
            url = f"https://api.github.com/repos/TennisGazelle/blender-pipeline/zipball/v{VERSION}"
            log.info(f'fetching latest {self.release_zip} from {url}...')
            r = requests.get(url)
            open(self.release_zip, 'wb+').write(r.content)

        # ensuring tempdir/self.release_dir (made from the self.release_zip) is made
        if not os.path.exists(self.release_dir) or not os.path.isdir(self.release_dir):
            log.info(f'extracting zip...')
            with zipfile.ZipFile(self.release_zip, 'r') as zip_file:
                top_level_dir = zip_file.infolist()[0].filename
                zip_file.extractall(tempdir)
                os.rename(tempdir + top_level_dir, self.release_dir)

                # blender_pipeline_dir = "blender-pipeline-" + VERSION + "/"






if __name__ == "__main__":
    v = Validator()
    v.generate_project()



# CONFIG_FILE='./config.yaml'


# def init_config():
#     # validate the yaml first
#     import yamale
#     schema = yamale.make_schema(SCHEMA_FILE)
#     # Create a Data object
#     data = yamale.make_data(CONFIG_FILE)
#     # Validate data against the schema. Throws a ValueError if data is invalid.
#     yamale.validate(schema, data)

#     # return it if it works
#     with open('config.yaml', 'r') as config_file:
#         config = yaml.load(config_file)#, Loader=yaml.FullLoader) # fix this